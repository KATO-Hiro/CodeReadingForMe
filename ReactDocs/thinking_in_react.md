# Thinking in React

## 現状

+ 関数コンポーネントを使ったチュートリアルの三目並べを写経。

+ チュートリアルの後半は理解度を上げる必要がある。
  + コンポーネントのリフトアップを行う必要があるケース、状態と操作をどのコンポーネントで持つといいか?

+ 仕様を書き出して、そこからどのように考えるとよりReactらしいコードになるかを知る必要がある

## 目標

+ 新しいサービスで実現したい機能を実装できるように。

+ 。

## 技術選定の理由

+ 。

+ 。

## Thinking in React

+ Reactを使ってユーザーインターフェースを構築する場合、まずそれをコンポーネントと呼ばれる断片に分解する。次に、コンポーネントごとに異なる視覚的な状態を記述します。最後に、データがコンポーネント間を流れるようにコンポーネントを接続します。

+ チュートリアルでは、Reactを使って検索可能な商品データテーブルを構築する思考プロセスを説明

### Start with the mockup

+ JSON APIとデザイナーによるモックアップがあるとする。

```json
// 商品のカテゴリ、値段、在庫の有無、商品名
[
  { category: "Fruits", price: "$1", stocked: true, name: "Apple" },
  { category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit" },
  { category: "Fruits", price: "$2", stocked: false, name: "Passionfruit" },
  { category: "Vegetables", price: "$2", stocked: true, name: "Spinach" },
  { category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin" },
  { category: "Vegetables", price: "$1", stocked: true, name: "Peas" }
]
```

+ モックアップ
  + 検索用のテキストボックスが一番上にある
  + チェックボックスで、在庫がある場合のみ表示できるように
  + フルーツと野菜でカテゴリ分け
    + 名前と商品をそれぞれテーブル形式で表示
    + 在庫がない場合は、赤文字で表示

+ ReactでUIを実装するには、通常同じ5つのステップを踏むことになる。

### ステップ 1：UI をコンポーネントの階層に分割する

+ まず最初に、モックアップのすべてのコンポーネントとサブコンポーネントを四角で囲んで、それぞれに名前を付ける
  + JSON がうまく構造化されている場合、それが UI のコンポーネント構造に自然に対応
  + 1 つのコンポーネントがデータモデルの 1 つの部分に対応するような形で、UI をコンポーネントに分割
  + 命名: HogeFugaの形式
+ モックアップ内にあるコンポーネントを特定したら、それらを階層構造に整理

```md
- FilterableProductTable
  - SearchBar
  - ProductTable
    - ProductCategoryRow
    - ProductRow
```

### ステップ 2: React で静的なバージョンを作成

+ 静的なバージョンを先に構築し、後からインタラクティブ性を追加する方が、多くの場合は簡単なため
  + 静的なバージョン: タイプ量が多い代わりに考えることはほどんどない
  + インタラクティブな要素: タイプ量が少ない代わりに考えることが多い
+ 静的バージョンのアプリを作成
  + コンポーネントを作成していく際に、他のコンポーネントを再利用しつつ props 経由でそれらにデータを渡す
  + stateの概念に馴染みがある場合でも、静的なバージョンを作成している間は stateを一切使わない
  + 単純な例ではトップダウン、大規模なプロジェクトではボトムアップで進める方が簡単

+ コンポーネントはJSXを返すのみ
+ 階層の一番上のコンポーネント (FilterableProductTable) が、データモデルを props として受け取り
+ 単方向データフロー (one-way data flow) : データがトップレベルのコンポーネントからツリーの下の方にあるコンポーネントに流れていく構造

### ステップ 3：UI の状態を最小限かつ完全に表現する方法を見つける

+ state: アプリが記憶する必要のある、変化するデータの最小限のセット
  + DRYの原則が大事
  + 他のものは必要になったらその場で計算
  + 使われるデータを列挙
+ stateでないともの特定する基準
  + 時間が経過しても変化しない
  + 親コンポーネントからprops経由で渡される
  + コンポーネント内の既存のstateやpropsに基づいて計算可能

### ステップ 4：state を保持すべき場所を特定

+ Reactでは単方向データフロー、つまり親から子コンポーネントへと階層を下る形でのみデータが渡される
+ 各stateを記述する位置を特定する手順

1. 該当するstateに基づいて何かを描画するすべてのコンポーネントを列挙
2. 階層内でそれらすべての上に位置する、最も近い共通の親コンポーネントを見つける
3. state がどこにあるべきかを決定
  + 多くの場合、state をその共通の親に直接置く
  + その共通の親のさらに上にあるコンポーネントに置くこともできる
  + 適切なコンポーネントが見つからない場合は、state を保持するためだけの新しいコンポーネントを作成し、共通の親コンポーネントの階層の上のどこかに追加

### ステップ 5：逆方向のデータフローを追加

+ ユーザの入力に従って state を変更するには、逆方向へのデータの流れをサポートする必要がある = 階層の深いところにあるフォームコンポーネントが、上位の階層にに存在する state を更新できる必要がある
  + 下位のコンポーネントから、コンポーネントの上位のstateを更新するには、setHogeを下位のコンポーネントに渡す必要がある
  + 下位のコンポーネントで、イベントハンドラ(onChangeなど)を追加し、それらか親のstateを設定

## 疑問点

+ Q: コンポーネントの最小単位はどれくらいにするか?
  + A: 1 つのコンポーネントは理想的には 1 つのことだけを行うべき

+ propsとstateの違いは?
  + props: 関数に渡す引数のようなもの
  + state: コンポーネントのメモリのようなもの。コンポーネントが情報を追跡し、ユーザ操作に反応して変更できるようにする

## 感想

+ 。

+ 。

## 抽象化

+ 。

+ 。

## 応用

+ 。

+ 。

## See
